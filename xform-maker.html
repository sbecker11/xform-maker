<!DOCTYPE html>
<html lang="en" class=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-Form Maker</title>
    <script>
        // Inline script to set theme class ASAP to prevent flicker
        (function() {
            const themeKey = 'xformMakerTheme';
            const savedTheme = localStorage.getItem(themeKey);
            if (savedTheme === 'dark') {
                document.documentElement.classList.add('dark-theme');
            }
        })();
        
        // --- LocalStorage Keys (Global) ---
        const STORAGE_KEY = 'xformMaker_savedForms';
        const STATE_STORAGE_KEY = 'xformMaker_currentState';
        
        // --- Timer for name updates ---
        window.timeUpdateTimer = null;
        
        // --- Define global helper functions ---
        window.getSavedXForms = function() {
            const saved = localStorage.getItem(STORAGE_KEY);
            return saved ? JSON.parse(saved) : [];
        };
        
        window.saveXForms = function(xforms) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(xforms));
        };
        
        // Last used directory for file operations
        window.lastUsedDirHandle = null;
        
        // --- Define global element references ---
        window.savedListUl = null; // Will be set after DOM is loaded
        window.selectedControlsDiv = null;
        window.renameInput = null;
        window.selectedSavedXFormId = null;
        window.intermediatePoints = [];
        window.waypointCounter = null;
        window.addWaypointButton = null;
        window.deleteLastWaypointButton = null;
        window.xRotationDirection = 1;
        window.yRotationDirection = 1;
        window.zRotationDirection = 1;
        window.durationInput = null;
        
        // Define the makeDraggableWaypoint function on the window object
        window.makeDraggableWaypoint = function(element, index) {
            let isDragging = false;
            
            element.addEventListener('mousedown', (e) => {
                // Remove this check to allow dragging in WAM mode
                // if (isAddingPoints) return;
                
                isDragging = true;
                window.draggingPointIndex = index;
                lastModifiedPointIndex = index; // Update last modified point
                wasDraggingPoint = false;
                
                // Get initial positions for drag calculation
                const vpRect = viewport.getBoundingClientRect();
                dragOffsetX = e.clientX - (vpRect.left + window.intermediatePoints[index].x);
                dragOffsetY = e.clientY - (vpRect.top + window.intermediatePoints[index].y);
                
                // Select this point and deselect others
                window.intermediatePoints.forEach((p, i) => {
                    if (p.element) {
                        if (i === index) {
                            p.element.classList.add('selected');
                        } else {
                            p.element.classList.remove('selected');
                        }
                    }
                });
                
                selectedPointIndex = index;
                e.stopPropagation(); // Prevent viewport click
                e.preventDefault();
            });
            
            // Handle point movement in global mouse handlers
        };
        
        // --- Global UI Helper Functions ---
        window.renderSavedList = function() {
            if (!window.savedListUl) {
                console.log("Skipping render of saved list - savedListUl element not found");
                return; // Exit early if the element doesn't exist
            }
            
            const xforms = window.getSavedXForms();
            window.savedListUl.innerHTML = ''; // Clear existing list
            window.selectedSavedXFormId = null; // Clear selection
            
            if (window.selectedControlsDiv) {
                window.selectedControlsDiv.style.display = 'none'; // Hide controls
            }

            if (xforms.length === 0) {
                window.savedListUl.innerHTML = '<li>No X-Forms saved yet.</li>';
                return;
            }

            xforms.forEach(t => {
                const li = document.createElement('li');
                li.dataset.id = t.id;

                const nameSpan = document.createElement('span');
                nameSpan.className = 'xform-name';
                nameSpan.textContent = t.name;
                li.appendChild(nameSpan);

                // Simple indication of complexity (optional)
                const detailsSpan = document.createElement('span');
                detailsSpan.style.fontSize = '0.8em';
                detailsSpan.style.color = '#6c757d';
                detailsSpan.textContent = `(${t.waypoints ? t.waypoints.length : 0} pts)`;
                li.appendChild(detailsSpan);

                li.addEventListener('click', () => {
                    // Remove selected class from previous
                    Array.from(window.savedListUl.querySelectorAll('li.selected')).forEach(el => el.classList.remove('selected'));

                    // Toggle selection
                    if (window.selectedSavedXFormId === t.id) {
                        window.selectedSavedXFormId = null;
                        if (window.selectedControlsDiv) {
                            window.selectedControlsDiv.style.display = 'none';
                        }
                    } else {
                        window.selectedSavedXFormId = t.id;
                        li.classList.add('selected');
                        if (window.renameInput) {
                            window.renameInput.value = t.name; // Pre-fill rename input
                        }
                        if (window.selectedControlsDiv) {
                            window.selectedControlsDiv.style.display = 'block';
                        }
                        console.log('Selected saved X-Form:', t.id);
                    }
                });
                window.savedListUl.appendChild(li);
            });
        };
    </script>
    <style>
        body {
            margin: 20px;
            font-family: Arial, sans-serif;
            background-color: var(--bg-color-primary);
            color: var(--text-color-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full height */
        }
        
        /* Filename section styles for Phase 1 & 2 */
        .filename-section {
            margin-bottom: 15px;
        }
        
        .filename-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .filename-header label {
            font-weight: bold;
            margin-bottom: 0;
        }
        
        .mode-icons {
            display: flex;
            gap: 5px;
            padding-right: 11px;
        }
        
        .mode-icon {
            background: none;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 2px 5px;
            cursor: pointer;
            font-size: 0.9em;
            opacity: 0.6;
            transition: all 0.2s ease;
            color: var(--text-color-primary);
        }
        
        .mode-icon.active {
            opacity: 1;
            background-color: var(--button-bg);
            border-color: var(--button-hover-bg);
            color: white;
        }
        
        .filename-input-container {
            position: relative;
            width: 100%;
        }
        
        .time-based-filename {
            width: 100%;
            padding-top: 8px;
            padding-bottom: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
            font-family: monospace;
            background-color: white;
            color: black;
            font-size: 14px;
            margin-bottom: 0; /* Override default margin */
        }
        
        /* Style for readonly input to ensure it doesn't look disabled */
        .time-based-filename[readonly] {
            opacity: 1; 
            background-color: var(--bg-color-secondary);
            color: var(--text-color-primary);
            cursor: pointer; /* Indicates it can be clicked for MEM mode */
            -webkit-user-select: text; /* Ensures text is selectable */
            user-select: text;
        }

        .file-list-section {
            margin-top: 10px;
        }

        .file-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0px;
        }
        
        .files-sort-biutton {
            background-color: var(--button-bg);
            width: 20px;
            height:20px;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px;
            margin-right: 17px;
            padding-bottom: 0px;
            cursor: pointer;
            font-weight: normal;
            transition: background-color 0.2s;
        }

        .file-list-container {
            width: 240px; /* Adjust width as needed */
            height: 245px; /* Fixed height for scrolling */
            border: 1px solid #ccc;
            overflow-y: auto; /* Enable vertical scrolling */
            padding: 2px;
            margin-top: 10px;
        }

        .file-list {
            list-style: none;
            padding: 0;
            margin: 0;
            background-color: white;
        }

        .file-list li {
            padding: 4px;
            border-bottom: 1px solid #eee;
            color: black;
        }

        .file-list li:last-child {
            border-bottom: none;
        }


        /* Save button styles */
        .save-button-container {
            margin-top: 5px;
            margin-bottom: 20px;
            display: flex;
            justify-content: flex-end;
            padding-right: 11px;
        }
        
        .save-button {
            background-color: var(--button-bg);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 20px;
            padding-top: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        
        .save-button:hover {
            background-color: var(--button-hover-bg);
        }
        
        .three-column-layout {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1100px; /* Reduced max-width */
            align-items: flex-start; /* Align items to the top */
            position: relative; /* Needed for viewport-actions positioning */
        }
        .left-column {
            flex: 1; /* Allow left column to grow */
            min-width: 240px; /* Match what browser is actually using */
            max-width: 280px; /* Limit maximum width */
            padding: 20px;
            padding-left: 0;
            padding-right: 0;
            background-color: var(--bg-color-secondary);
            border-radius: 8px;
            box-shadow: var(--shadow-elevation-low);
            height: fit-content; /* Adjust height based on content */
            border: none; /* Remove previous border, use fieldset */
            display: flex; /* Use flexbox for children */
            flex-direction: column; /* Stack fieldsets vertically */
            gap: 15px; /* Space between fieldsets */
        }
        .right-column {
            flex: 0 0 210px; /* Increased by 10px from 200px to 210px */
            padding: 20px 0 20px 20px; /* Keep top, bottom, left padding, remove right padding */
            background-color: var(--bg-color-secondary);
            border-radius: 8px;
            box-shadow: var(--shadow-elevation-low);
            height: fit-content; /* Adjust height based on content */
            border: none; /* Remove previous border, use fieldset */
            display: flex; /* Use flexbox for children */
            flex-direction: column; /* Stack fieldsets vertically */
            gap: 15px; /* Space between fieldsets */
            box-sizing: border-box; /* Include padding in width calculation */
            max-width: 210px; /* Enforce maximum width, increased by 10px */
            width: 210px; /* Explicit width, increased by 10px */
        }
        .center-column {
            flex: 0 0 auto; /* Don't grow or shrink, keep current size */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            position: relative; /* Positioning context for theme toggle */
            padding-top: 0; /* Removed padding (was 44px) */
        }
        #viewport {
            position: relative; /* Needed for absolute positioning of rects */
            background-color: white; /* Keep background */
            border-radius: 8px;
            /* Bevel effect */
            border: 1px solid #aaa;
            box-shadow: inset 3px 3px 6px rgba(0,0,0,0.2),
                        inset -2px -2px 5px rgba(255,255,255,0.6),
                        0 4px 8px rgba(0,0,0,0.15); /* Optional outer shadow */
            overflow: hidden;
            width: 400px; /* Reduced width */
            height: 400px; /* Reduced height */
            perspective: 1000px; /* Enable 3D space for children */
        }
        .rect {
            position: absolute;
            width: 100px;
            height: 60px;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
            box-sizing: border-box; /* Include padding/border in element's total width and height */
            transform-style: preserve-3d; /* Important for containing 3D transforms */
            transition: transform 0.5s ease-in-out; /* Default transition */
        }
        .rect-start {
            background-color: rgba(0, 128, 0, 0.8); /* Green, semi-transparent */
            border: 2px solid darkgreen;
            z-index: 1; /* Start rect below */
            cursor: grab; /* Make it grabbable */
            position: absolute; /* Keep absolute positioning */
        }
        .rect-end {
            background-color: rgba(255, 0, 0, 0.8); /* Red, semi-transparent */
            border: 2px solid darkred;
            z-index: 2; /* End rect above, draggable */
            position: absolute; /* Keep absolute positioning */
        }
        .rect-end:active {
            cursor: grabbing;
        }
        .controls-column h2,
        .persistence-column h2 {
            margin-top: 0;
            margin-bottom: 10px; /* Space below H2 inside fieldset */
            font-size: 1.1em; /* Slightly smaller H2 */
        }
        fieldset {
            /* border: 1px solid var(--border-color-strong); Remove border */
            border: none;
            border-radius: 6px;
            padding: 15px;
            margin: 0; /* Reset default fieldset margin */
            width: 100%; /* Take full width of parent column */
            box-sizing: border-box;
        }
        .persistence-fieldset {
            padding-top: 0;
            padding-right: 0;
        }
        /* legend {
            padding: 0 5px;
            font-weight: bold;
            color: var(--text-color-primary);
            margin-left: 10px; 
            font-size: 1em;
        } */

        /* Style the new labels as section headers */
        .control-section > label {
            display: block; /* Make label take full width */
            font-weight: bold;
            margin-bottom: 10px; /* Space below label */
            font-size: 1.1em;
            color: var(--text-color-primary);
        }

        .control-section {
            /* padding: 2px 0; Further reduce vertical padding */
            padding: 0; /* Remove padding, rely on gap */
        }

        .control-group {
             margin-bottom: 5px; /* Further reduce space */
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="number"], input[type="text"] {
            width: calc(100% - 16px);
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.secondary {
            background-color: #6c757d;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }
         button.danger {
            background-color: #dc3545;
        }
        button.danger:hover {
            background-color: #c82333;
        }
        #savedList { /* Target the ul directly */
            list-style: none;
            padding: 0;
            max-height: 300px; /* Keep max-height */
            overflow-y: auto;
        }
         #savedList li { /* Target li directly */
            padding: 10px;
            border: 1px solid #eee;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .saved-xforms li:hover {
            background-color: #f8f9fa;
        }
        .saved-xforms li.selected {
            background-color: #e0e0e0;
            font-weight: bold;
        }
        .xform-name {
             flex-grow: 1;
             margin-right: 10px;
             overflow: hidden;
             text-overflow: ellipsis;
             white-space: nowrap;
        }
        .direction-toggle span:first-child { /* Target the label span specifically */
            display: inline-block;
            width: 30px; /* Fixed width for alignment */
            color: var(--text-color-primary);
        }
        .rot-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-left: 0px; /* Remove left margin */
            margin-right: 8px;
            vertical-align: middle;
            background-size: contain; /* Or 16px 16px */
            background-repeat: no-repeat;
            background-position: center;
        }
        .rot-icon[data-axis="x"] { background-image: url('icons/x-rot.png'); }
        .rot-icon[data-axis="y"] { background-image: url('icons/y-rot.png'); }
        .rot-icon[data-axis="z"] { background-image: url('icons/z-rot.png'); }
        .dark-theme .rot-icon[data-axis="x"] { background-image: url('icons/x-rot-dark.png'); }
        .dark-theme .rot-icon[data-axis="y"] { background-image: url('icons/y-rot-dark.png'); }
        .dark-theme .rot-icon[data-axis="z"] { background-image: url('icons/z-rot-dark.png'); }
        .direction-toggle button {
            padding: 5px 0; /* Adjust padding for consistent height */
            font-size: 0.9em; /* Slightly smaller text */
            width: 30px; /* Fixed width for all */
            min-width: auto; /* Allow button to be smaller */
            margin-left: 5px;
            margin-bottom: 5px; /* Add bottom margin */
            text-align: center;
            line-height: 1.2; /* Adjust for vertical centering */
        }
        .direction-toggle button.active {
            background-color: #28a745; /* Green for active */
            border: 1px solid #1e7e34;
            opacity: 1.0;
        }
        .direction-toggle button:not(.active) {
            background-color: #6c757d; /* Grey for inactive */
            opacity: 0.7;
        }
        /* Specific style for active zero button */
        .direction-toggle button[data-value="0"].active {
             background-color: #ffc107; /* Yellow for zero */
             color: #333;
             border-color: #e0a800;
             opacity: 1.0;
        }
        .point-marker {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: rgba(0, 0, 255, 0.7);
            border: 1px solid darkblue;
            border-radius: 50%;
            cursor: pointer;
            transform: translate(-50%, -50%); /* Center the marker on the click point */
            z-index: 3; /* Above rects */
        }
        .point-marker.selected {
            background-color: rgba(0, 255, 255, 0.9); /* Cyan when selected */
            border: 2px solid teal;
        }

        /* Header */
        .app-header {
            width: 100%;
            display: flex;
            /* justify-content: space-between; Let button be positioned independently */
            align-items: center;
            padding: 10px 20px;
            box-sizing: border-box;
            /* margin-bottom: 15px; Reduce space below header */
            margin-bottom: 5px;
        }
        .app-header h1 {
            margin: 0;
            flex-grow: 1;
            margin-bottom: 10px; /* Add some space below title */
        }

        #themeToggle {
            position: relative; /* Changed from absolute to relative positioning */
            z-index: 10; /* Ensure it's clickable */
            width: 60px;
            height: 24px;
            border-radius: 12px; /* height / 2 */
            border: 1px solid var(--border-color-strong);
            background-color: var(--bg-color-toggle-off);
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-sizing: border-box;
            appearance: none; /* Remove default button styles */
            /* Clear content for pseudo-element */
            color: transparent;
            font-size: 0;
            line-height: 0;
            margin: 5px; /* Set all four margins to 5px */
        }

        #themeToggle::before {
            content: '';
            position: absolute;
            width: 20px; /* Size of the switch circle */
            height: 20px;
            border-radius: 50%;
            background-color: var(--bg-color-toggle-switch);
            top: 1px; /* Center vertically */
            left: 1px;
            transition: transform 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .dark-theme #themeToggle {
            background-color: var(--bg-color-toggle-on);
        }

        .dark-theme #themeToggle::before {
            transform: translateX(36px); /* Adjust based on size/padding */
        }

        /* Layout */
        .three-column-layout {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1100px; /* Reduced max-width */
            align-items: flex-start; /* Align items to the top */
            position: relative; /* Needed for viewport-actions positioning */
        }

        /* Block size controls row */
        .block-size-controls {
            display: flex;
            align-items: center;
            gap: 5px; /* Reduced gap */
            /* Calculate total width similar to duration */
            /* Label width can be flexible */
        }
        .block-size-controls label {
             margin-bottom: 0; /* Remove bottom margin for inline label */
             white-space: nowrap;
             flex-shrink: 0; /* Prevent label from shrinking */
             margin-right: auto; /* Push inputs/button to the right */
             line-height: 28px; /* Align label vertically */
        }
        .block-size-controls input[type="number"] {
            width: 87px; /* Increased by another 4px from 83px */
            margin-bottom: 0;
            height: 100%; /* Match parent height */
            box-sizing: border-box;
            margin-right: 5px; /* Add right margin */
        }
        .block-size-controls span { /* The 'x' */
            margin: 0 2px;
        }
        .block-size-controls button {
            margin-bottom: 0;
            flex-shrink: 0; /* Prevent button from shrinking */
            padding: 10px 8px; /* Increase top/bottom padding */
            min-width: auto; /* Allow button to be smaller */
            height: 100%; /* Match parent height */
            box-sizing: border-box;
        }

        /* Viewport Actions (Start/Replay/Reset) */
        .viewport-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            width: 100%; /* Span width below viewport */
            margin-top: 10px; /* Space above buttons */
        }

        .right-column {
            /* margin-top: -40px; Remove this adjustment for now */
        }

        .direction-toggle {
            display: flex; /* Use flexbox to keep elements in a row */
            align-items: center; /* Vertically align label, icon, buttons */
            margin-bottom: 8px; /* Space between rows */
        }

        #duration { /* Specific style for duration input */
            width: 168px; /* Increased by 30px from 138px */
            margin-left: auto; /* Push input to the right if label is short */
        }

        /* Controls specific to the right column */
        .right-column input[type="number"] {
            box-sizing: border-box;
        }
        
        /* Rectangle size controls specific styling */
        .block-size-controls {
            display: flex;
            gap: 12px; /* Space between width and height inputs */
            width: 170px; /* Set total width */
        }
        
        .block-size-controls input[type="number"] {
            width: 79px; /* (170px - 12px gap) / 2 */
        }
        
        .right-column .waypoint-btn {
            min-width: 40px; /* Reduce from 50px */
        }
        
        /* Duration control layout */
        .duration-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .duration-left {
            display: flex;
            align-items: center;
        }
        
        #durationFeedback {
            margin-left: auto; /* Push to the right */
            font-size: 0.9em;
            color: var(--text-color-secondary);
            text-align: right;
            display: none; /* Hide the element */
        }

        /* Waypoint controls row */
        .waypoint-controls {
            display: flex;
            align-items: center;
            /* padding: 0 5px; Remove padding */
            /* gap: 10px; Add gap between elements */
            gap: 6px; /* Reduce gap */
        }
        .waypoint-controls > button:first-child {
            margin-right: 0; /* Override auto margin */
        }

        .waypoint-btn { /* Class for Add/Del buttons */
            text-align: center;
        }

        #waypointCounter {
            font-weight: bold;
            color: var(--text-color-secondary);
            /* min-width: 25px; Tighter width for 2 digits */
            min-width: 40px; /* Adjusted width */
            text-align: center;
        }

        #deleteLastWaypointButton[disabled] { /* Simpler selector test */
            background-color: #cccccc !important; /* Light grey background - Force */
            color: #888888 !important; /* Dimmer text - Force */
            cursor: not-allowed !important; /* Force cursor */
        }

        /* Optional: Explicitly prevent hover style changes */
        #deleteLastWaypointButton[disabled]:hover { /* Simpler selector test */
            background-color: #cccccc !important; /* Keep it grey - Force */
            /* color: #888888; Keep text dim */
        }

        :root {
            --bg-color-primary: #f0f0f0;
            --bg-color-secondary: #ffffff;
            --text-color-primary: #333333;
            --text-color-secondary: #666666;
            --border-color: #dddddd;
            --border-color-strong: #aaaaaa;
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --button-danger-bg: #dc3545;
            --button-danger-hover-bg: #c82333;
            --shadow-elevation-low: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-elevation-medium: 0 4px 8px rgba(0,0,0,0.1);
            --text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            /* Theme Toggle Colors (Light) */
            --bg-color-toggle-off: #cccccc; /* Grey when off (light theme) */
            --bg-color-toggle-on: #007bff; /* Blue when on (light theme) */
            --bg-color-toggle-switch: #ffffff; /* White switch */
        }

        .dark-theme {
            --bg-color-primary: #22272e;
            --bg-color-secondary: #2d333b;
            --text-color-primary: #cdd9e5;
            --text-color-secondary: #97a6b7;
            --border-color: #444c56;
            --border-color-strong: #586069;
            --button-bg: #3081f7;
            --button-hover-bg: #458ff7;
            --button-danger-bg: #f85149;
            --button-danger-hover-bg: #fa675f;
            --shadow-elevation-low: 0 1px 2px rgba(0,0,0,0.2);
            --shadow-elevation-medium: 0 4px 8px rgba(0,0,0,0.3);
            --text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            /* Theme Toggle Colors (Dark) */
            --bg-color-toggle-off: #586069; /* Dark grey when off (dark theme) */
            --bg-color-toggle-on: #3081f7;  /* Blue when on (dark theme) */
            --bg-color-toggle-switch: #22272e; /* Dark switch */
        }

        /* Utility Classes */
        .no-select {
            user-select: none; /* Standard */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE/Edge */
        }
        
        /* Icon buttons */
        .icon-btn {
            padding: 6px;
            min-width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--button-bg);
        }
        
        .btn-icon {
            width: 16px;
            height: 16px;
        }
        
        /* List item icon buttons */
        .list-icon-btn {
            padding: 3px;
            min-width: 24px;
            height: 24px;
            background-color: transparent;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.7;
            border-radius: 3px;
        }
        
        .list-icon-btn:hover {
            opacity: 1;
            background-color: rgba(0,0,0,0.1);
        }
        
        .btn-icon-small {
            width: 14px;
            height: 14px;
        }
        
        /* Dark theme icon switching */
        .dark-theme .btn-icon[data-dark-src] {
            content: attr(data-dark-src);
        }

        .right-column fieldset {
            /* border: 1px solid var(--border-color-strong); Remove border */
            border: none;
            border-radius: 6px;
            padding: 15px 0 15px 0; /* Remove left/right padding for fieldsets in the right column */
            margin: 0; /* Reset default fieldset margin */
            width: 100%; /* Take full width of parent column */
            box-sizing: border-box;
        }

        /* Specific padding adjustments for Add and Del buttons */
        #addWaypointBtn {
            padding-right: 10px; /* Reduced from default 15px */
        }
        
        #deleteLastWaypointBtn {
            padding-left: 10px; /* Reduced from default 15px */
        }
    </style>
</head>
<body>

    <div class="app-header">
        <h1>XForm Maker</h1>
    </div>

    <div class="three-column-layout">
        <!-- Left: Persistence -->
        <div class="left-column persistence-column">
            <fieldset class="persistence-fieldset">
                <!-- <legend>X-Form Management</legend> -->
                
                <!-- Filename section with ATM/MEM modes (Phase 1 & 2) -->
                <div class="control-group filename-section">
                    <div class="filename-header">
                        <label>X-Form Filename</label>
                        <div class="mode-icons">
                            <button id="filenameModeATM" class="mode-icon active" title="Automated Time Mode">
                                <span>(t)</span>
                            </button>
                            <button id="filenameModeManual" class="mode-icon" title="Manual Edit Mode">
                                <span>(e)</span>
                            </button>
                        </div>
                    </div>
                    <div class="filename-input-container">
                        <input type="text" id="filenameInput" class="time-based-filename" readonly="true">
                    </div>
                </div>
                
                <!-- Save Button -->
                <div class="control-group save-button-container">
                    <button id="saveFileBtn" class="save-button">Save</button>
                </div>

                <div class="control-group file-list-section">
                    <div class="file-list-header">
                        <label>X-Form Files</label> <button class="files-sort-biutton">(^)</button>
                    </div>
                    <div class="file-list-container">
                        <ul class="file-list">
                            <li>document1.txt</li>
                            <li>image2.jpg</li>
                            <li>script3.py</li>
                            <li>notes4.pdf</li>
                            <li>document5.txt</li>
                            <li>image6.jpg</li>
                            <li>script7.py</li>
                            <li>notes8.pdf</li>
                            <li>document9.txt</li>
                            <li>image10.jpg</li>
                            <li>script11.py</li>
                            <li>notes12.pdf</li>
                            <li>document13.txt</li>
                            <li>image14.jpg</li>
                            <li>script15.py</li>
                            <li>notes16.pdf</li>
                            <li>document17.txt</li>
                            <li>image18.jpg</li>
                            <li>script19.py</li>
                            <li>notes20.pdf</li>
                            <li>document21.txt</li>
                            <li>image22.jpg</li>
                                <!-- Add more filenames as needed -->
                        </ul>
                    </div> 
                </div>

            </fieldset>
        </div>

        <!-- Center: Viewport & Actions -->
        <div class="center-column">
            <div id="viewport" style="cursor: crosshair;"><div id="startRect" class="rect rect-start" style="width: 103px; height: 133px; left: 78.5px; top: 49.5px;">Start</div><div id="endRect" class="rect rect-end" style="width: 103px; height: 133px; left: 250.5px; top: 217.5px;">End</div></div>
            <div class="viewport-actions">
                <button id="startAnimation">Play</button>
                <button id="resetPositions">Reset</button>
                <button id="themeToggle" title="Toggle Theme"></button>
            </div>
        </div>

        <!-- Right: Controls -->
        <div class="right-column controls-column">
            <div class="control-section">
                <label for="rotations">Rotations:</label>
                <div class="control-group" style="margin-bottom: 5px;">
                    <div class="direction-toggle" data-axis="x" data-direction="1">
                        <span>X:</span><span class="rot-icon" data-axis="x"></span>
                        <button class="btn-dir active" data-value="1">+</button>
                        <button class="btn-dir" data-value="0">0</button>
                        <button class="btn-dir" data-value="-1">-</button>
                    </div>
                    <div class="direction-toggle" data-axis="y" data-direction="1">
                        <span>Y:</span><span class="rot-icon" data-axis="y"></span>
                        <button class="btn-dir active" data-value="1">+</button>
                        <button class="btn-dir" data-value="0">0</button>
                        <button class="btn-dir" data-value="-1">-</button>
                    </div>
                    <div class="direction-toggle" data-axis="z" data-direction="1">
                        <span>Z:</span><span class="rot-icon" data-axis="z"></span>
                        <button class="btn-dir active" data-value="1">+</button>
                        <button class="btn-dir" data-value="0">0</button>
                        <button class="btn-dir" data-value="-1">-</button>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <div class="duration-container">
                    <div class="duration-left">
                        <label for="duration">Duration (ms):</label>
                    </div>
                    <span id="durationFeedback" style="color: var(--text-color-secondary);">(1.4s)</span>
                </div>
                <div class="control-group">
                    <input type="number" id="duration" value="500" min="100" step="50" max="5000">
                </div>
            </div>

            <div class="control-section">
                <label for="rectangle">Rectangle:</label>
                <div class="control-group block-size-controls">
                    <input type="number" id="rectWidth" value="100" min="50" max="400" title="Width (50-400px)">
                    <input type="number" id="rectHeight" value="60" min="50" max="400" title="Height (50-400px)">
                </div>
            </div>

            <div class="control-section">
                <label for="waypoints">Waypoints:</label>
                <div class="control-group waypoint-controls">
                    <button id="addWaypointBtn" class="waypoint-btn" style="background-color: rgb(0, 123, 255); border-color: rgb(0, 86, 179);">Add +</button>
                    <span id="waypointCounter">0</span>
                    <button id="deleteLastWaypointBtn" class="waypoint-btn" style="pointer-events: none; opacity: 0.5; cursor: not-allowed;" disabled="">- Del</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Loaded. Initializing XForm Maker...');

            // Set global DOM element references
            window.addWaypointButton = document.getElementById('addWaypointBtn');
            window.waypointCounter = document.getElementById('waypointCounter');
            window.deleteLastWaypointButton = document.getElementById('deleteLastWaypointBtn');
            window.savedListUl = document.getElementById('savedList');
            window.selectedControlsDiv = document.getElementById('selectedXFormControls');
            window.renameInput = document.getElementById('renameInput');

            // --- DOM Elements (Declare ONCE) ---
            const viewport = document.getElementById('viewport');
            window.widthInput = document.getElementById('rectWidth');
            window.heightInput = document.getElementById('rectHeight');
            const applySizeButton = document.getElementById('applySize');
            window.durationInput = document.getElementById('duration');
            const startButton = document.getElementById('startAnimation');
            const resetButton = document.getElementById('resetPositions');
            
            // Set global references
            window.selectedSavedXFormId = null;
            window.renameXFormButton = document.getElementById('renameXFormBtn');
            window.renameXFormInput = document.getElementById('renameXFormInput');
            
            const renameButton = document.getElementById('renameXForm');
            const deleteButton = document.getElementById('deleteXForm');
            const loadButton = document.getElementById('loadXForm');
            const currentNameDisplay = document.getElementById('currentXFormName');
            const namingConventionSelect = document.getElementById('namingConvention');
            const saveToFileButton = document.getElementById('saveToFileBtn');
            const loadFromFileButton = document.getElementById('loadFromFileBtn');
            const saveButton = document.getElementById('saveXForm'); // Main save button
            window.themeToggleButton = document.getElementById('themeToggle');
            console.log("Initial check - themeToggleButton element:", themeToggleButton);

            // NOTE: startRect and endRect are created dynamically, so use 'let'
            let startRect = null;
            let endRect = null;

            // --- State Variables ---
            let xRotationDirection = 1;
            let yRotationDirection = 1;
            let zRotationDirection = 1;
            let isAddingPoints = true; // Always in WAM mode
            window.intermediatePoints = []; // Array to store {x, y, element} of intermediate points
            let selectedPointIndex = -1; // Index of the selected intermediate point
            window.draggingPointIndex = -1; // Index of the point being dragged
            let lastModifiedPointIndex = -1; // Track most recently modified point
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            let selectedSavedXFormId = null;
            let wasDraggingPoint = false; // Flag to prevent click after drag
            let isRectangleDragging = false; // Flag to track rectangle dragging

            // --- Current X-Form State ---
            let currentXFormName = "New X-Form";
            let currentXFormId = null; // Can be null (new) or a timestamp (run/loaded/saved)
            let currentXFormHasRun = false;

            // --- Filename mode variables (Phase 1 & 2) ---
            window.isFilenameModeATM = true; // Start in Automated Time Mode, make it global
            let filenameUpdateInterval = null;
            const FILENAME_MODE_KEY = 'xformMaker_filenameMode';
            const FILENAME_VALUE_KEY = 'xformMaker_filenameValue';
            
            // --- Filename mode functions (Phase 1 & 2) ---
            function setupFilenameMode() {
                const filenameInput = document.getElementById('filenameInput');
                const atmButton = document.getElementById('filenameModeATM');
                const memButton = document.getElementById('filenameModeManual');
                const saveButton = document.getElementById('saveFileBtn');
                
                if (!filenameInput || !atmButton || !memButton) {
                    console.error("Filename mode elements not found");
                    return;
                }
                
                console.log("Setting up filename mode - elements found:", 
                    { filenameInput: !!filenameInput, atmButton: !!atmButton, memButton: !!memButton });
                
                // Restore saved mode and filename
                const savedMode = localStorage.getItem(FILENAME_MODE_KEY);
                const savedFilename = localStorage.getItem(FILENAME_VALUE_KEY);
                
                // Set initial mode (default to ATM if not saved)
                window.isFilenameModeATM = savedMode !== 'MEM';
                
                // Update UI based on mode
                if (window.isFilenameModeATM) {
                    atmButton.classList.add('active');
                    memButton.classList.remove('active');
                    filenameInput.setAttribute('readonly', true);
                    
                    // Initial filename update
                    updateFilenameWithTime();
                    
                    // Start automatic updates
                    startFilenameTimeUpdates();
                } else {
                    memButton.classList.add('active');
                    atmButton.classList.remove('active');
                    filenameInput.removeAttribute('readonly');
                    
                    // Set saved filename or default
                    if (savedFilename) {
                        filenameInput.value = savedFilename;
                    } else {
                        updateFilenameWithTime(); // Set once, but won't update automatically
                    }
                }
                
                // ATM mode button click handler
                atmButton.addEventListener('click', () => {
                    if (!window.isFilenameModeATM) {
                        // Switch to ATM mode
                        window.isFilenameModeATM = true;
                        atmButton.classList.add('active');
                        memButton.classList.remove('active');
                        filenameInput.setAttribute('readonly', true);
                        
                        // Save mode to localStorage
                        localStorage.setItem(FILENAME_MODE_KEY, 'ATM');
                        
                        // Immediately update with current time
                        updateFilenameWithTime();
                        
                        // Start automatic updates
                        startFilenameTimeUpdates();
                        
                        console.log("Switched to Automated Time Mode");
                    }
                });
                
                // MEM mode button click handler
                memButton.addEventListener('click', () => {
                    if (window.isFilenameModeATM) {
                        // Switch to MEM mode
                        window.isFilenameModeATM = false;
                        memButton.classList.add('active');
                        atmButton.classList.remove('active');
                        filenameInput.removeAttribute('readonly');
                        
                        // Save mode to localStorage
                        localStorage.setItem(FILENAME_MODE_KEY, 'MEM');
                        
                        // Stop automatic updates
                        stopFilenameTimeUpdates();
                        
                        // Focus the input for editing
                        filenameInput.focus();
                        
                        console.log("Switched to Manual Edit Mode");
                    }
                });
                
                // Save button click handler
                if (saveButton) {
                    saveButton.addEventListener('click', async () => {
                        // Make sure currentXFormName is updated with the latest filename
                        currentXFormName = filenameInput.value;
                        
                        // Save the file
                        const success = await saveXFormToFile();
                        
                        if (success) {
                            console.log("File saved successfully with filename:", filenameInput.value);
                        }
                    });
                }
                
                // Double-click on input to switch to MEM mode
                filenameInput.addEventListener('dblclick', () => {
                    if (window.isFilenameModeATM) {
                        // Simulate click on MEM button
                        memButton.click();
                    }
                });
                
                // Save manually edited filename
                filenameInput.addEventListener('change', () => {
                    if (!window.isFilenameModeATM) {
                        // Save the manually edited value
                        localStorage.setItem(FILENAME_VALUE_KEY, filenameInput.value);
                        console.log("Saved manually edited filename");
                    }
                });
            }
            
            function startFilenameTimeUpdates() {
                // Clear any existing interval
                stopFilenameTimeUpdates();
                
                console.log("Starting automated time updates");
                
                // Update immediately
                updateFilenameWithTime();
                
                // Set up a new interval for time updates (every second)
                filenameUpdateInterval = setInterval(() => {
                    console.log("Time update interval triggered");
                    updateFilenameWithTime();
                }, 1000);
                
                // Keep a reference to the interval
                console.log("Interval ID:", filenameUpdateInterval);
            }
            
            // Export functions to global scope
            window.startFilenameTimeUpdates = startFilenameTimeUpdates;
            
            function stopFilenameTimeUpdates() {
                if (filenameUpdateInterval) {
                    clearInterval(filenameUpdateInterval);
                    filenameUpdateInterval = null;
                }
            }
            
            // Export to global scope
            window.stopFilenameTimeUpdates = stopFilenameTimeUpdates;
            
            function updateFilenameWithTime() {
                const filenameInput = document.getElementById('filenameInput');
                if (!filenameInput) {
                    console.error("Filename input element not found");
                    return;
                }
                
                if (!window.isFilenameModeATM) {
                    console.log("Not updating time - currently in manual edit mode");
                    return;
                }
                
                const now = new Date();
                const formattedDate = now.toISOString().slice(0, 10).replace(/-/g, '-');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const timeStr = `${hours}:${minutes}:${seconds}`;
                
                // Create the new filename
                const newFilename = `${formattedDate} ${timeStr}`;
                
                // Update input field
                filenameInput.value = newFilename;
                
                // Update the currentXFormName to use this filename for saving files
                currentXFormName = newFilename;
                
                // Save to localStorage for persistence
                localStorage.setItem(FILENAME_VALUE_KEY, newFilename);
                
                console.log("Updated filename with current time:", newFilename);
            }
            
            // Export to global scope
            window.updateFilenameWithTime = updateFilenameWithTime;

            // --- X-Form Naming Functions ---
            function generateXFormName() {
                // Since we don't have namingConventionSelect anymore,
                // always use the datetime convention
                const now = new Date();
                const formattedDate = now.toLocaleDateString();
                const formattedTime = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                return `X-Form ${formattedDate} ${formattedTime}`;
            }
            
            // Validate and sanitize X-Form name
            function sanitizeXFormName(name) {
                if (!name || typeof name !== 'string') return generateXFormName();
                
                // Remove any characters that might cause issues in filenames
                let sanitized = name.trim()
                    .replace(/[<>:"/\\|?*]/g, '')  // Remove invalid filename characters
                    .replace(/\s+/g, ' ');         // Replace multiple spaces with single space
                
                // If empty after sanitizing, use generated name
                if (sanitized.length === 0) return generateXFormName();
                
                // If name doesn't start with "X-Form", add it
                if (!sanitized.toLowerCase().startsWith('x-form')) {
                    sanitized = `X-Form ${sanitized}`;
                }
                
                return sanitized;
            }
            
            // --- X-Form File Operations ---
            // Get the current filename based on mode (ATM or MEM)
            function getCurrentFilename() {
                const filenameInput = document.getElementById('filenameInput');
                if (filenameInput) {
                    // Return the value from the filename input (already updated in ATM mode)
                    return filenameInput.value || "Unnamed X-Form";
                }
                
                // Fallback to existing currentXFormName if input is not found
                return currentXFormName || "Unnamed X-Form";
            }
            
            // Save X-Form to JSON file
            async function saveXFormToFile() {
                try {
                    // Create the X-Form data object
                    const xformData = createXFormDataObject();
                    
                    // Get the current filename (from ATM/MEM input)
                    const currentFilename = getCurrentFilename();
                    
                    // Use the filename for both the X-Form name and the file
                    xformData.name = currentFilename;
                    
                    // Sanitize the filename for file system
                    const filename = `${currentFilename.replace(/[<>:"/\\|?*]/g, '').replace(/\s+/g, '_')}.json`;
                    
                    // Use the File System Access API to save the file
                    const options = {
                        suggestedName: filename,
                        types: [{
                            description: 'X-Form JSON',
                            accept: {'application/json': ['.json']}
                        }]
                    };
                    
                    // If we have a previously used directory, start there
                    if (window.lastUsedDirHandle) {
                        try {
                            options.startIn = window.lastUsedDirHandle;
                        } catch (e) {
                            console.error("Couldn't use last directory:", e);
                        }
                    }
                    
                    const fileHandle = await window.showSaveFilePicker(options);
                    
                    // Save the directory for future use
                    try {
                        window.lastUsedDirHandle = await fileHandle.getParent();
                        console.log("Saved directory for future use");
                    } catch (e) {
                        console.error("Couldn't save directory:", e);
                    }
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(xformData, null, 2));
                    await writable.close();
                    
                    console.log(`X-Form exported to file: ${filename}`);
                    alert(`X-Form exported to file: ${filename}`);
                    
                    return true;
                } catch (error) {
                    console.error('Error saving X-Form to file:', error);
                    if (error.name !== 'AbortError') {
                        alert(`Error exporting X-Form: ${error.message || 'Unknown error'}`);
                    }
                    return false;
                }
            }
            
            // Load X-Form from JSON file
            async function loadXFormFromFile() {
                try {
                    // File picker options
                    const options = {
                        types: [{
                            description: 'X-Form JSON',
                            accept: {'application/json': ['.json']}
                        }]
                    };
                    
                    // If we have a previously used directory, start there
                    if (window.lastUsedDirHandle) {
                        try {
                            options.startIn = window.lastUsedDirHandle;
                        } catch (e) {
                            console.error("Couldn't use last directory:", e);
                        }
                    }
                    
                    // Use the File System Access API to open a file
                    const [fileHandle] = await window.showOpenFilePicker(options);
                    
                    // Save the directory for future use
                    try {
                        window.lastUsedDirHandle = await fileHandle.getParent();
                        console.log("Saved directory for future use");
                    } catch (e) {
                        console.error("Couldn't save directory:", e);
                    }
                    
                    const file = await fileHandle.getFile();
                    const contents = await file.text();
                    const xformData = JSON.parse(contents);
                    
                    // Apply the loaded data
                    applyXFormData(xformData);
                    
                    console.log(`X-Form imported from file: ${file.name}`);
                    
                    // Extract name from filename if not in the data
                    if (!xformData.name) {
                        const nameFromFile = file.name.replace(/\.json$/, '').replace(/_/g, ' ');
                        currentXFormName = sanitizeXFormName(nameFromFile);
                    }
                    
                    // Also save to local storage
                    saveCurrentXFormToStorage();
                    
                    // Update UI
                    updateCurrentXFormDisplay();
                    window.renderSavedList();
                    
                    return true;
                } catch (error) {
                    console.error('Error loading X-Form from file:', error);
                    if (error.name !== 'AbortError') {
                        alert(`Error importing X-Form: ${error.message || 'Unknown error'}`);
                    }
                    return false;
                }
            }
            
            // Create a complete X-Form data object
            function createXFormDataObject() {
                return {
                    name: currentXFormName,
                    id: currentXFormId || Date.now(),
                    timestamp: Date.now(),
                    startRect: {
                        left: startRect ? parseFloat(startRect.style.left) || 0 : 0,
                        top: startRect ? parseFloat(startRect.style.top) || 0 : 0,
                        width: parseInt(widthInput.value, 10),
                        height: parseInt(heightInput.value, 10)
                    },
                    endRect: {
                        left: endRect ? parseFloat(endRect.style.left) || 0 : 0,
                        top: endRect ? parseFloat(endRect.style.top) || 0 : 0,
                        width: parseInt(widthInput.value, 10),
                        height: parseInt(heightInput.value, 10)
                    },
                    waypoints: window.intermediatePoints.map(point => ({
                        x: point.x,
                        y: point.y
                    })),
                    rotations: {
                        x: xRotationDirection,
                        y: yRotationDirection,
                        z: zRotationDirection
                    },
                    duration: parseInt(window.durationInput.value, 10)
                };
            }
            
            // Apply loaded X-Form data to the application
            function applyXFormData(data) {
                // Set transition info
                currentXFormName = data.name || "Loaded X-Form";
                currentXFormId = data.id || Date.now();
                currentXFormHasRun = true;
                
                // Set dimensions
                if (data.startRect) {
                    widthInput.value = data.startRect.width;
                    heightInput.value = data.startRect.height;
                    applyRectangleSize(); // Apply to both rectangles
                }
                
                // Apply positions
                if (startRect && data.startRect) {
                    startRect.style.left = `${data.startRect.left}px`;
                    startRect.style.top = `${data.startRect.top}px`;
                }
                
                if (endRect && data.endRect) {
                    endRect.style.left = `${data.endRect.left}px`;
                    endRect.style.top = `${data.endRect.top}px`;
                }
                
                // Clear existing waypoints
                window.intermediatePoints.forEach(p => p.element && p.element.remove());
                window.intermediatePoints = [];
                
                // Add new waypoints
                if (data.waypoints && Array.isArray(data.waypoints)) {
                    data.waypoints.forEach(point => {
                        const marker = document.createElement('div');
                        marker.className = 'point-marker';
                        marker.style.left = `${point.x}px`;
                        marker.style.top = `${point.y}px`;
                        viewport.appendChild(marker);
                        
                        const pointData = { 
                            x: point.x, 
                            y: point.y, 
                            element: marker 
                        };
                        window.intermediatePoints.push(pointData);
                        
                        window.makeDraggableWaypoint(marker, window.intermediatePoints.length - 1);
                    });
                }
                
                // Rotation settings
                if (data.rotations) {
                    xRotationDirection = data.rotations.x;
                    yRotationDirection = data.rotations.y;
                    zRotationDirection = data.rotations.z;
                    updateRotationButtonsUI();
                }
                
                // Set duration
                if (data.duration) {
                    window.durationInput.value = data.duration;
                    if (document.getElementById('durationFeedback')) {
                        const seconds = (data.duration / 1000).toFixed(1);
                        document.getElementById('durationFeedback').textContent = `(${seconds}s)`;
                    }
                }
                
                // Update UI
                window.updateWaypointCounter();
                window.saveCurrentState(); // Save to localStorage
            }
            
            // --- UI Updates for X-Form Management ---
            function updateCurrentXFormDisplay() {
                if (currentNameDisplay) {
                    currentNameDisplay.textContent = currentXFormName || "New X-Form";
                    renameXFormInput.value = currentXFormName || "";
                }
            }
            
            // --- X-Form Management UI Setup ---
            function setupXFormManagement() {
                // Skip if UI elements are missing (which they are in this version)
                if (!renameXFormButton || !renameXFormInput) {
                    console.log("Skipping X-Form management setup - elements not found");
                    return;
                }
                
                // Initialize current X-Form display
                if (currentNameDisplay) {
                    currentNameDisplay.textContent = currentXFormName || "New X-Form";
                    renameXFormInput.value = currentXFormName || "";
                }
                
                // Setup rename functionality
                renameXFormButton.addEventListener('click', () => {
                    const newName = sanitizeXFormName(renameXFormInput.value);
                    currentXFormName = newName;
                    
                    if (currentNameDisplay) {
                        currentNameDisplay.textContent = newName;
                    }
                    
                    saveCurrentState();
                    
                    // Update saved X-Form if this is an existing one
                    if (currentXFormId) {
                        const xforms = window.getSavedXForms();
                        const index = xforms.findIndex(t => t.id === currentXFormId);
                        if (index >= 0) {
                            xforms[index].name = newName;
                            window.saveXForms(xforms);
                            if (window.renderSavedList) {
                                window.renderSavedList();
                            }
                        }
                    }
                    
                    // Show confirmation
                    const origText = renameXFormButton.innerHTML;
                    renameXFormButton.innerHTML = `<span style="color: #4CAF50;"></span>`;
                    setTimeout(() => {
                        renameXFormButton.innerHTML = origText;
                    }, 1500);
                });
                
                // Setup file operation buttons
                if (saveToFileButton) {
                    saveToFileButton.addEventListener('click', saveXFormToFile);
                }
                
                if (loadFromFileButton) {
                    loadFromFileButton.addEventListener('click', loadXFormFromFile);
                }
                
                // Update the load X-Form button
                if (loadButton) {
                    loadButton.addEventListener('click', () => {
                        if (selectedSavedXFormId) {
                            const xforms = window.getSavedXForms();
                            const selected = xforms.find(t => t.id === selectedSavedXFormId);
                            
                            if (selected) {
                                applyXFormData(selected);
                                console.log(`Loaded X-Form: ${selected.name}`);
                            }
                        }
                    });
                }
                
                console.log("X-Form management setup completed");
            }

            // --- Function to apply saved theme ---
            function applyTheme(theme) {
                const htmlElement = document.documentElement; // Target <html> tag
                if (theme === 'dark') {
                    htmlElement.classList.add('dark-theme');
                } else {
                    htmlElement.classList.remove('dark-theme');
                }
                localStorage.setItem('xformMakerTheme', theme); // Updated key name
                
                // Update icons based on theme
                if (typeof updateIconsForTheme === 'function') {
                    setTimeout(updateIconsForTheme, 50);
                }
            }

            // --- State Management Functions ---
            // Save current application state
            window.saveCurrentState = function() {
                // Create state object with all current settings
                const state = {
                    // Rectangle properties
                    startRect: {
                        left: startRect ? parseFloat(startRect.style.left) || 0 : 0,
                        top: startRect ? parseFloat(startRect.style.top) || 0 : 0,
                        width: startRect ? parseFloat(startRect.style.width) || parseInt(widthInput.value, 10) : parseInt(widthInput.value, 10),
                        height: startRect ? parseFloat(startRect.style.height) || parseInt(heightInput.value, 10) : parseInt(heightInput.value, 10)
                    },
                    endRect: {
                        left: endRect ? parseFloat(endRect.style.left) || 0 : 0,
                        top: endRect ? parseFloat(endRect.style.top) || 0 : 0,
                        width: endRect ? parseFloat(endRect.style.width) || parseInt(widthInput.value, 10) : parseInt(widthInput.value, 10),
                        height: endRect ? parseFloat(endRect.style.height) || parseInt(heightInput.value, 10) : parseInt(heightInput.value, 10)
                    },
                    // Waypoints (without DOM elements)
                    waypoints: window.intermediatePoints.map(point => ({
                        x: point.x,
                        y: point.y
                    })),
                    // Rotation settings
                    rotations: {
                        x: xRotationDirection,
                        y: yRotationDirection,
                        z: zRotationDirection
                    },
                    // Duration setting
                    duration: parseInt(window.durationInput.value, 10),
                    // Current X-Form info
                    currentXForm: {
                        name: currentXFormName,
                        id: currentXFormId,
                        hasRun: currentXFormHasRun
                    },
                    // Last modified point index
                    lastModifiedPointIndex: lastModifiedPointIndex,
                    // Theme
                    theme: document.documentElement.classList.contains('dark-theme') ? 'dark' : 'light'
                };
                
                // Store in localStorage
                localStorage.setItem(STATE_STORAGE_KEY, JSON.stringify(state));
                console.log('Current state saved to localStorage');
            }
            
            // Restore application state from localStorage
            function restoreState() {
                const savedState = localStorage.getItem(STATE_STORAGE_KEY);
                if (!savedState) {
                    console.log('No saved state found, starting with default state');
                    return false;
                }
                
                try {
                    const state = JSON.parse(savedState);
                    console.log('Found saved state:', state); // Debug info
                    
                    // Restore rectangle dimensions in inputs
                    if (state.startRect) {
                        widthInput.value = state.startRect.width;
                        heightInput.value = state.startRect.height;
                    }
                    
                    // Apply settings to rects after they've been created
                    if (startRect && state.startRect) {
                        console.log('Restoring startRect position to:', 
                                    `left=${state.startRect.left}px, top=${state.startRect.top}px`);
                        startRect.style.left = `${state.startRect.left}px`;
                        startRect.style.top = `${state.startRect.top}px`;
                        startRect.style.width = `${state.startRect.width}px`;
                        startRect.style.height = `${state.startRect.height}px`;
                    }
                    
                    if (endRect && state.endRect) {
                        console.log('Restoring endRect position to:',
                                   `left=${state.endRect.left}px, top=${state.endRect.top}px`);
                        endRect.style.left = `${state.endRect.left}px`;
                        endRect.style.top = `${state.endRect.top}px`;
                        endRect.style.width = `${state.endRect.width}px`;
                        endRect.style.height = `${state.endRect.height}px`;
                    }
                    
                    // Restore waypoints
                    window.intermediatePoints = [];
                    if (state.waypoints && Array.isArray(state.waypoints)) {
                        state.waypoints.forEach(point => {
                            // Create visual waypoint markers
                            const marker = document.createElement('div');
                            marker.className = 'point-marker';
                            marker.style.left = `${point.x}px`;
                            marker.style.top = `${point.y}px`;
                            viewport.appendChild(marker);
                            
                            // Store waypoint data with DOM element reference
                            const pointData = { 
                                x: point.x, 
                                y: point.y, 
                                element: marker 
                            };
                            window.intermediatePoints.push(pointData);
                            
                            // Make marker draggable
                            window.makeDraggableWaypoint(marker, window.intermediatePoints.length - 1);
                        });
                    }
                    
                    // Restore rotation settings
                    if (state.rotations) {
                        // Update both local and global rotation variables
                        xRotationDirection = state.rotations.x;
                        yRotationDirection = state.rotations.y;
                        zRotationDirection = state.rotations.z;
                        
                        // Also update the global versions
                        window.xRotationDirection = state.rotations.x;
                        window.yRotationDirection = state.rotations.y;
                        window.zRotationDirection = state.rotations.z;
                        
                        // Update active buttons
                        updateRotationButtonsUI();
                        console.log('Restored rotation settings:', state.rotations);
                    }
                    
                    // Restore duration
                    if (state.duration) {
                        window.durationInput.value = state.duration;
                    }
                    
                    // Restore current X-Form info
                    if (state.currentXForm) {
                        currentXFormName = state.currentXForm.name;
                        currentXFormId = state.currentXForm.id;
                        currentXFormHasRun = state.currentXForm.hasRun;
                        updateCurrentXFormDisplay(); // Update UI with X-Form name
                    }
                    
                    // Restore last modified point index
                    if (typeof state.lastModifiedPointIndex !== 'undefined') {
                        lastModifiedPointIndex = state.lastModifiedPointIndex;
                    }
                    
                    // Restore theme
                    if (state.theme) {
                        applyTheme(state.theme);
                    }
                    
                    // Update waypoint counter
                    window.updateWaypointCounter();
                    
                    console.log('State successfully restored from localStorage');
                    return true;
                } catch (error) {
                    console.error('Error restoring state:', error);
                    return false;
                }
            }

            // --- Bezier/Spline Calculation Helpers ---
            // Calculates control points for a segment p1-p2 based on neighbors p0, p3 and tension
            function getControlPoints(p0, p1, p2, p3, tension = 0.5) {
                // Catmull-Rom to Cubic Bezier conversion formula
                const d1x = (p2.x - p0.x) * tension;
                const d1y = (p2.y - p0.y) * tension;
                const d2x = (p3.x - p1.x) * tension;
                const d2y = (p3.y - p1.y) * tension;

                const cp1 = { x: p1.x + d1x / 3, y: p1.y + d1y / 3 };
                const cp2 = { x: p2.x - d2x / 3, y: p2.y - d2y / 3 };
                return [cp1, cp2];
            }

            // Calculates a point on a cubic Bezier curve defined by p0, cp1, cp2, p1 at time t (0-1)
            function getPointOnCubicBezier(p0, cp1, cp2, p1, t) {
                const t2 = t * t;
                const t3 = t2 * t;
                const mt = 1 - t;
                const mt2 = mt * mt;
                const mt3 = mt2 * mt;

                const x = mt3 * p0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * p1.x;
                const y = mt3 * p0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * p1.y;
                return { x, y };
            }

            // Generates a dense list of points along a spline path defined by the input points
            function generateSplinePath(points, samplesPerSegment = 30) {
                if (points.length < 2) return points;

                const path = [points[0]]; // Start with the first point
                const numSegments = points.length - 1;

                for (let i = 0; i < numSegments; i++) {
                    const p0 = points[Math.max(0, i - 1)]; // Previous point (or p0 if i=0)
                    const p1 = points[i];                     // Start of segment
                    const p2 = points[i + 1];                 // End of segment
                    const p3 = points[Math.min(numSegments, i + 2)]; // Next point (or pN if i=N-1)

                    const [cp1, cp2] = getControlPoints(p0, p1, p2, p3);

                    // Sample points along this cubic Bezier segment
                    for (let t = 1; t <= samplesPerSegment; t++) {
                        const sampleT = t / samplesPerSegment;
                        path.push(getPointOnCubicBezier(p1, cp1, cp2, p2, sampleT));
                    }
                }
                // Ensure the very last point is included exactly if needed (sampling might slightly miss)
                // path.push(points[points.length - 1]); // Usually sampling gets close enough
                return path;
            }

            // --- Initial Setup ---
            function initializeRects() {
                // Clear existing rects if any (for reset)
                viewport.innerHTML = '';

                // Create and Style Start Rect (Green)
                startRect = document.createElement('div'); // Assign to outer 'let' variable
                startRect.id = 'startRect';
                startRect.className = 'rect rect-start';
                startRect.textContent = 'Start';
                viewport.appendChild(startRect);
                // Center it initially
                const vpRect = viewport.getBoundingClientRect();
                 // Apply current size from inputs before getting bounding rect
                const currentWidth = parseInt(widthInput.value, 10);
                const currentHeight = parseInt(heightInput.value, 10);
                if (!isNaN(currentWidth) && currentWidth >= 10) startRect.style.width = `${currentWidth}px`;
                if (!isNaN(currentHeight) && currentHeight >= 10) startRect.style.height = `${currentHeight}px`;
                const sRect = startRect.getBoundingClientRect(); // Get bounds after setting size
                const initialX = (vpRect.width - sRect.width) / 2;
                const initialY = (vpRect.height - sRect.height) / 2;
                startRect.style.left = `${initialX}px`;
                startRect.style.top = `${initialY}px`;
                startRect.style.transform = ''; // Reset transform

                // Create and Style End Rect (Red) - initially same as start
                endRect = document.createElement('div'); // Assign to outer 'let' variable
                endRect.id = 'endRect';
                endRect.className = 'rect rect-end';
                endRect.textContent = 'End';
                // Apply current size
                if (!isNaN(currentWidth) && currentWidth >= 10) endRect.style.width = `${currentWidth}px`;
                if (!isNaN(currentHeight) && currentHeight >= 10) endRect.style.height = `${currentHeight}px`;
                viewport.appendChild(endRect);
                endRect.style.left = `${initialX}px`;
                endRect.style.top = `${initialY}px`;
                endRect.style.transform = ''; // Reset transform

                console.log('Rects Initialized at:', initialX, initialY);
                // Clear old intermediate points
                window.intermediatePoints.forEach(p => p.element.remove());
                window.intermediatePoints = [];
                selectedPointIndex = -1;
                isAddingPoints = false;
                window.addWaypointButton.textContent = 'Add';
                window.addWaypointButton.style.backgroundColor = '#28a745';
                // Reset viewport cursor if it was crosshair
                viewport.style.cursor = 'default';

                 // Re-attach drag listener
                 if (startRect) makeDraggable(startRect);
                 if (endRect) makeDraggable(endRect);

                 // Reset current X-Form state
                 currentXFormName = "New X-Form";
                 currentXFormId = null;
                 currentXFormHasRun = false;
                 startButton.textContent = 'Play'; // Set button text
            }

            // --- Dragging Logic ---
            function makeDraggable(element) {
                let isDragging = false;
                let startX, startY, initialMouseX, initialMouseY;

                element.addEventListener('mousedown', (e) => {
                    // Ensure element is valid
                    if (!element) return;
                    isDragging = true;
                    isRectangleDragging = true; // Set global flag for rectangle dragging
                    element.style.cursor = 'grabbing';
                    element.style.transition = 'none'; // Disable transition during drag

                    // Record initial position of the element and mouse
                    const rect = element.getBoundingClientRect();
                    const viewportRect = viewport.getBoundingClientRect();

                    // Positions relative to viewport top-left
                    startX = rect.left - viewportRect.left;
                    startY = rect.top - viewportRect.top;
                    initialMouseX = e.clientX;
                    initialMouseY = e.clientY;

                    // Prevent default drag behavior (like selecting text)
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging || !element) return;

                    // Calculate mouse movement
                    const dx = e.clientX - initialMouseX;
                    const dy = e.clientY - initialMouseY;

                    // Calculate new position
                    let newX = startX + dx;
                    let newY = startY + dy;

                    // Constrain within viewport bounds
                    const vpRect = viewport.getBoundingClientRect();
                    const elRect = element.getBoundingClientRect();
                    newX = Math.max(0, Math.min(newX, vpRect.width - elRect.width));
                    newY = Math.max(0, Math.min(newY, vpRect.height - elRect.height));

                    element.style.left = `${newX}px`;
                    element.style.top = `${newY}px`;
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging && element) {
                        isDragging = false;
                        isRectangleDragging = false; // Reset global rectangle dragging flag
                        element.style.cursor = 'grab';
                        element.style.transition = ''; // Re-enable transition
                        console.log(`${element.id} Dropped at:`, element.style.left, element.style.top);
                        
                        // Immediately save state after rectangle is moved
                        saveCurrentState();
                        
                        // Log current state to verify it's being saved
                        console.log("Rectangle positions saved to localStorage:", 
                            JSON.parse(localStorage.getItem(STATE_STORAGE_KEY)));
                    }
                });
                 // Prevent dragging the element itself (browser default)
                 element.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });
            }

             // --- Reset Button ---
            resetButton.addEventListener('click', initializeRects);

             // --- Resize Logic ---
            function applyRectangleSize() {
                const newWidth = parseInt(widthInput.value, 10);
                const newHeight = parseInt(heightInput.value, 10);

                // Enforce limits: 50px minimum, 400px maximum
                const validWidth = Math.max(50, Math.min(400, newWidth));
                const validHeight = Math.max(50, Math.min(400, newHeight));
                
                // Update input values if they were clamped
                if (validWidth !== newWidth) {
                    widthInput.value = validWidth;
                }
                if (validHeight !== newHeight) {
                    heightInput.value = validHeight;
                }

                if (isNaN(validWidth) || isNaN(validHeight)) {
                    console.warn('Invalid rectangle dimensions');
                    return;
                }

                // Get viewport bounds for validation
                const vpRect = viewport.getBoundingClientRect();

                // Resize both rectangles while maintaining their current centers
                [startRect, endRect].forEach(rect => {
                    if (!rect) return;
                    
                    // Get current position and size
                    const currentLeft = parseFloat(rect.style.left) || 0;
                    const currentTop = parseFloat(rect.style.top) || 0;
                    const currentWidth = rect.offsetWidth;
                    const currentHeight = rect.offsetHeight;
                    
                    // Calculate current center point
                    const centerX = currentLeft + (currentWidth / 2);
                    const centerY = currentTop + (currentHeight / 2);
                    
                    // Apply new size
                    rect.style.width = `${validWidth}px`;
                    rect.style.height = `${validHeight}px`;
                    
                    // Reposition to maintain the same center
                    const newLeft = centerX - (validWidth / 2);
                    const newTop = centerY - (validHeight / 2);
                    
                    // Keep within viewport bounds
                    const boundedLeft = Math.max(0, Math.min(newLeft, vpRect.width - validWidth));
                    const boundedTop = Math.max(0, Math.min(newTop, vpRect.height - validHeight));
                    
                    rect.style.left = `${boundedLeft}px`;
                    rect.style.top = `${boundedTop}px`;
                });

                console.log(`Resized rectangles to ${validWidth}x${validHeight} while maintaining centers`);
            }

            // Add event listeners for interactive updates
            widthInput.addEventListener('change', applyRectangleSize);
            heightInput.addEventListener('change', applyRectangleSize);
            // Input event for real-time updates as user types or uses spinner
            widthInput.addEventListener('input', applyRectangleSize);
            heightInput.addEventListener('input', applyRectangleSize);

            // Load saved theme on startup - Add this line back
            const savedTheme = localStorage.getItem('transformMakerTheme') || 'light';

            // --- Set up rotation button event handlers --- //
            function setupRotationControls() {
                // Select all rotation button groups
                const directionToggles = document.querySelectorAll('.direction-toggle');
                
                directionToggles.forEach(toggle => {
                    const axis = toggle.getAttribute('data-axis');
                    const buttons = toggle.querySelectorAll('.btn-dir');
                    
                    buttons.forEach(button => {
                        button.addEventListener('click', () => {
                            // Remove active class from all buttons in this toggle
                            buttons.forEach(b => b.classList.remove('active'));
                            
                            // Add active class to clicked button
                            button.classList.add('active');
                            
                            // Get the value from the button's data attribute
                            const value = parseInt(button.getAttribute('data-value'), 10);
                            
                            // Update the corresponding rotation direction variable
                            if (axis === 'x') {
                                xRotationDirection = value;
                                window.xRotationDirection = value; // Update global variable
                                console.log(`X rotation direction set to: ${value}`);
                            } else if (axis === 'y') {
                                yRotationDirection = value;
                                window.yRotationDirection = value; // Update global variable
                                console.log(`Y rotation direction set to: ${value}`);
                            } else if (axis === 'z') {
                                zRotationDirection = value;
                                window.zRotationDirection = value; // Update global variable
                                console.log(`Z rotation direction set to: ${value}`);
                            }
                            
                            // Update the data-direction attribute on the parent toggle
                            toggle.setAttribute('data-direction', value);
                        });
                    });
                });
                
                console.log("Rotation control event handlers set up");
            }

            // --- Duration Control Setup --- //
            function setupDurationControl() {
                // Set constraints for animation duration
                const MIN_DURATION = 100; // ms
                const MAX_DURATION = 5000; // ms
                const DEFAULT_DURATION = 500; // ms
                
                // Update input attributes to match constraints
                window.durationInput.min = MIN_DURATION;
                window.durationInput.max = MAX_DURATION;
                window.durationInput.step = 50;
                
                // Ensure initial value is within range
                const initialValue = parseInt(window.durationInput.value, 10);
                if (isNaN(initialValue) || initialValue < MIN_DURATION || initialValue > MAX_DURATION) {
                    window.durationInput.value = DEFAULT_DURATION;
                }
                
                // Get the existing duration feedback element
                const durationFeedback = document.getElementById('durationFeedback');
                if (!durationFeedback) {
                    console.error("Duration feedback element not found");
                    return;
                }
                
                // Update feedback text
                function updateDurationFeedback() {
                    const value = parseInt(window.durationInput.value, 10);
                    if (!isNaN(value)) {
                        const seconds = (value / 1000).toFixed(1);
                        durationFeedback.textContent = `(${seconds}s)`;
                        durationFeedback.style.color = 'var(--text-color-secondary)';
                    } else {
                        durationFeedback.textContent = '(invalid)';
                        durationFeedback.style.color = '#dc3545'; // Error color
                    }
                }
                
                // Validate and correct input
                function validateDuration() {
                    let value = parseInt(window.durationInput.value, 10);
                    
                    if (isNaN(value)) {
                        value = DEFAULT_DURATION;
                    } else {
                        // Clamp value to min/max range
                        value = Math.max(MIN_DURATION, Math.min(MAX_DURATION, value));
                    }
                    
                    // Update input if value changed
                    if (value !== parseInt(window.durationInput.value, 10)) {
                        window.durationInput.value = value;
                    }
                    
                    updateDurationFeedback();
                    return value;
                }
                
                // Event listeners
                window.durationInput.addEventListener('change', validateDuration);
                window.durationInput.addEventListener('input', updateDurationFeedback);
                
                // Initial feedback update
                updateDurationFeedback();
                
                console.log("Duration control set up with range:", MIN_DURATION, "-", MAX_DURATION, "ms");
            }

            // --- Viewport Action Buttons Setup --- //
            function setupViewportActions() {
                // Extract animation logic into a reusable function
                function applyXFormAnimation() {
                    console.log("Starting X-Form animation...");
                    
                    // Validate rectangle elements
                if (!startRect || !endRect) {
                    console.error("Start/End rectangle elements not found!");
                    return;
                }

                // Assign name/ID on first run if needed
                if (!currentXFormHasRun) {
                    if (currentXFormName === "New X-Form") {
                        currentXFormId = Date.now();
                        currentXFormName = `X-Form ${new Date(currentXFormId).toLocaleTimeString()}`;
                    }
                     // If it has a custom name but no ID, assign ID now
                     else if (!currentXFormId) {
                          currentXFormId = Date.now();
                     }
                    currentXFormHasRun = true;
                }

                // Update button text
                    startButton.textContent = 'Play';
                    
                    // Get validated duration
                    const duration = parseInt(window.durationInput.value, 10);
                    const durationSeconds = Math.max(0.1, duration / 1000); // Ensure minimum duration
                    
                    // Reset rectangle state first
                    startRect.style.animation = '';
                    startRect.style.transform = '';
                    
                    // Small delay to ensure reset took effect
                    setTimeout(() => {
                // Get Start/End Positions relative to viewport
                const startRectBounds = startRect.getBoundingClientRect();
                const endRectBounds = endRect.getBoundingClientRect();
                const vpRect = viewport.getBoundingClientRect();

                const startLeft = startRectBounds.left - vpRect.left;
                const startTop = startRectBounds.top - vpRect.top;
                const endLeft = endRectBounds.left - vpRect.left;
                const endTop = endRectBounds.top - vpRect.top;

                // Calculate Translation
                const translateX = endLeft - startLeft;
                const translateY = endTop - startTop;

                // --- Intermediate Points & Keyframes ---
                 const controlPoints = [
                    { x: startLeft, y: startTop }, // Start point
                            ...window.intermediatePoints.map(p => ({ x: p.x, y: p.y })), // Intermediate points
                    { x: endLeft, y: endTop } // End point
                 ];

                 // Generate a smooth path through the points
                 const smoothPath = generateSplinePath(controlPoints);

                        // Create keyframe animation for complex paths
                        if (smoothPath.length > 1) {
                     const keyframesName = `pathAnimation_${Date.now()}`;
                     let keyframesRule = `@keyframes ${keyframesName} {\n`;
                     const numPathPoints = smoothPath.length - 1;

                     // Generate keyframes based on the smooth path
                     smoothPath.forEach((point, index) => {
                         const percentage = (index / numPathPoints) * 100;
                         // Translate relative to the *initial* start position
                         const pointTranslateX = point.x - startLeft;
                         const pointTranslateY = point.y - startTop;
                         // Interpolate rotation based on overall percentage
                         const rotateXValue = xRotationDirection * 360 * (percentage / 100);
                         const rotateYValue = yRotationDirection * 360 * (percentage / 100);
                         const rotateZValue = zRotationDirection * 360 * (percentage / 100);

                         const transformValue = `translateX(${pointTranslateX}px) translateY(${pointTranslateY}px) rotateX(${rotateXValue}deg) rotateY(${rotateYValue}deg) rotateZ(${rotateZValue}deg)`;
                         keyframesRule += `  ${percentage}% { transform: ${transformValue}; }\n`;
                     });

                     keyframesRule += `}`;

                     // Inject keyframes into a style tag
                     const styleSheet = document.createElement("style");
                            styleSheet.textContent = keyframesRule;
                     document.head.appendChild(styleSheet);

                      // Apply animation
                            startRect.style.animation = `${keyframesName} ${durationSeconds}s ease-in-out forwards`; // Keep end state

                      // Clean up style tag and animation property after completion
                      setTimeout(() => {
                          startRect.style.animation = '';
                          startRect.style.transform = '';
                                styleSheet.remove(); // Remove the style element when done
                            }, duration + 100); // Add small buffer for animation completion
                 } else {
                      // Fallback to simple transition if no intermediate points
                      const transformValue = `translateX(${translateX}px) translateY(${translateY}px) rotateX(${xRotationDirection*360}deg) rotateY(${yRotationDirection*360}deg) rotateZ(${zRotationDirection*360}deg)`;
                      startRect.style.transition = `transform ${durationSeconds}s ease-in-out`;
                      startRect.style.transform = transformValue;
                            
                            // Reset after transition
                            setTimeout(() => {
                                startRect.style.transform = '';
                                startRect.style.transition = '';
                            }, duration + 100);
                        }
                    }, 50);
                }
                
                // --- Start Button Event Handler ---
                startButton.addEventListener('click', () => {
                    applyXFormAnimation();
                });
                
                // --- Reset Button Event Handler ---
                resetButton.addEventListener('click', () => {
                    // Clear any ongoing animations
                    if (startRect) {
                        startRect.style.animation = '';
                        startRect.style.transform = '';
                        startRect.style.transition = '';
                    }
                    
                    // Reinitialize rectangles
                    initializeRects();
                    
                    console.log("Viewport reset complete");
                });
                
                // Update button text to "Play" instead of "Start"
                startButton.textContent = 'Play';
                
                console.log("Viewport action buttons set up");
            }

            // --- Waypoint Controls Setup --- //
            function setupWaypointControls() {
                // Style Add button for permanent WAM mode
                function styleAddButton() {
                    window.addWaypointButton.textContent = 'Add +';
                    window.addWaypointButton.style.backgroundColor = '#007bff'; // Standard button blue
                    window.addWaypointButton.style.borderColor = '#0056b3'; // Darker blue border
                    viewport.style.cursor = 'crosshair'; // Always show crosshair in viewport
                }
                
                // Function to add a waypoint when clicked in the viewport
                function addWaypoint(clientX, clientY) {
                    const vpRect = viewport.getBoundingClientRect();
                    const x = clientX - vpRect.left;
                    const y = clientY - vpRect.top;
                    
                    // Create a visual marker for the waypoint
                    const marker = document.createElement('div');
                    marker.className = 'point-marker';
                    marker.style.left = `${x}px`;
                    marker.style.top = `${y}px`;
                    viewport.appendChild(marker);
                    
                    // Store waypoint data
                    const pointData = { x, y, element: marker };
                    window.intermediatePoints.push(pointData);
                    
                    // Set as the last modified point
                    lastModifiedPointIndex = window.intermediatePoints.length - 1;
                    
                    // Make marker draggable and selectable
                    window.makeDraggableWaypoint(marker, window.intermediatePoints.length - 1);
                    
                    // Update counter and Del button state
                    window.updateWaypointCounter();
                    
                    console.log(`Added waypoint at (${x}, ${y})`);
                    return pointData;
                }
                
                // Function to delete the most recently modified waypoint
                function deleteLastWaypoint() {
                    if (window.intermediatePoints.length === 0) return;
                    
                    // Determine which point to delete
                    const indexToDelete = (lastModifiedPointIndex >= 0 && lastModifiedPointIndex < window.intermediatePoints.length) 
                        ? lastModifiedPointIndex 
                        : window.intermediatePoints.length - 1; // Fallback to last point
                    
                    // Get the point to delete
                    const pointToDelete = window.intermediatePoints[indexToDelete];
                    
                    // Remove the point from the array using splice
                    window.intermediatePoints.splice(indexToDelete, 1);
                    
                    // Remove the visual marker
                    if (pointToDelete.element) {
                        pointToDelete.element.remove();
                    }
                    
                    // Update indexes after deletion
                    if (lastModifiedPointIndex >= window.intermediatePoints.length) {
                        lastModifiedPointIndex = window.intermediatePoints.length - 1;
                    }
                    
                    // Update the counter and Del button state
                    window.updateWaypointCounter();
                    
                    console.log(`Deleted waypoint at index ${indexToDelete}`);
                }
                
                // Make waypoint draggable
                function makeDraggableWaypoint(element, index) {
                    let isDragging = false;
                    
                    element.addEventListener('mousedown', (e) => {
                        // Remove this check to allow dragging in WAM mode
                        // if (isAddingPoints) return;
                        
                        isDragging = true;
                        window.draggingPointIndex = index;
                        lastModifiedPointIndex = index; // Update last modified point
                        wasDraggingPoint = false;
                        
                        // Get initial positions for drag calculation
                        const vpRect = viewport.getBoundingClientRect();
                        dragOffsetX = e.clientX - (vpRect.left + window.intermediatePoints[index].x);
                        dragOffsetY = e.clientY - (vpRect.top + window.intermediatePoints[index].y);
                        
                        // Select this point and deselect others
                        window.intermediatePoints.forEach((p, i) => {
                            if (p.element) {
                                if (i === index) {
                                    p.element.classList.add('selected');
                                } else {
                                    p.element.classList.remove('selected');
                                }
                            }
                        });
                        
                        selectedPointIndex = index;
                        e.stopPropagation(); // Prevent viewport click
                        e.preventDefault();
                    });
                    
                    // Handle point movement in global mouse handlers
                }
                
                // Make waypoint draggable - use the global function directly
                function makeDraggableWaypoint(element, index) {
                    // Call the global window.makeDraggableWaypoint function instead
                    return window.makeDraggableWaypoint(element, index);
                }
                
                // Event: Viewport click to add waypoint
                viewport.addEventListener('click', (e) => {
                    // Don't add waypoint if we just finished dragging
                    if (wasDraggingPoint || isRectangleDragging) {
                        wasDraggingPoint = false;
                        return;
                    }
                    
                    // Also don't add waypoint if clicked on an existing waypoint
                    if (e.target.classList.contains('point-marker')) {
                        return;
                    }
                    
                    // Don't add waypoint if we clicked on a rectangle
                    if (e.target === startRect || e.target === endRect) {
                        return;
                    }
                    
                    addWaypoint(e.clientX, e.clientY);
                });
                
                // Event: Add button click
                window.addWaypointButton.addEventListener('click', () => {
                    // Simply display a message in the console - button now only serves as a label
                    console.log('Add button clicked - you can click anywhere in the viewport to add waypoints');
                });
                
                // Event: Delete last waypoint button
                window.deleteLastWaypointButton.addEventListener('click', () => {
                    deleteLastWaypoint();
                });
                
                // Apply WAM styling
                styleAddButton();
                
                // Global mouse move for dragging waypoints
                document.addEventListener('mousemove', (e) => {
                    if (window.draggingPointIndex >= 0 && window.draggingPointIndex < window.intermediatePoints.length) {
                        wasDraggingPoint = true; // Set flag to prevent click after drag
                        
                        const vpRect = viewport.getBoundingClientRect();
                        const newX = e.clientX - vpRect.left - dragOffsetX;
                        const newY = e.clientY - vpRect.top - dragOffsetY;
                        
                        // Remove constraints - allow dragging outside viewport
                        // const constrainedX = Math.max(0, Math.min(newX, vpRect.width));
                        // const constrainedY = Math.max(0, Math.min(newY, vpRect.height));
                        
                        // Update point position
                        window.intermediatePoints[window.draggingPointIndex].x = newX;
                        window.intermediatePoints[window.draggingPointIndex].y = newY;
                        
                        // Update visual marker
                        const marker = window.intermediatePoints[window.draggingPointIndex].element;
                        if (marker) {
                            marker.style.left = `${newX}px`;
                            marker.style.top = `${newY}px`;
                        }
                    }
                });
                
                // Global mouse up to end waypoint dragging
                document.addEventListener('mouseup', (e) => {
                    if (window.draggingPointIndex >= 0) {
                        // Check if the point is outside the viewport
                        const vpRect = viewport.getBoundingClientRect();
                        const point = window.intermediatePoints[window.draggingPointIndex];
                        
                        // Calculate if point is outside viewport boundaries
                        const isOutside = 
                            point.x < -20 || // Allow slight margin outside
                            point.y < -20 || 
                            point.x > vpRect.width + 20 || 
                            point.y > vpRect.height + 20;
                        
                        if (isOutside) {
                            // Remove the point from the array
                            const removedPoint = window.intermediatePoints.splice(window.draggingPointIndex, 1)[0];
                            
                            // Remove the visual marker
                            if (removedPoint.element) {
                                removedPoint.element.remove();
                            }
                            
                            // Update last modified index after deletion
                            if (window.draggingPointIndex <= lastModifiedPointIndex) {
                                lastModifiedPointIndex = Math.max(0, lastModifiedPointIndex - 1);
                            }
                            
                            // Update counter
                            window.updateWaypointCounter();
                            
                            // Reset dragging flag to allow immediate waypoint creation
                            wasDraggingPoint = false;
                            
                            console.log('Waypoint deleted by dragging outside viewport');
                            
                            // Make sure we save the state AFTER the waypoint is removed
                            window.saveCurrentState();
                        } else {
                            // Point is still within viewport - update last modified
                            lastModifiedPointIndex = window.draggingPointIndex;
                            
                            // Remove selected styling
                            if (point && point.element) {
                                point.element.classList.remove('selected');
                            }
                            
                            // Constrain final position to within viewport
                            point.x = Math.max(0, Math.min(point.x, vpRect.width));
                            point.y = Math.max(0, Math.min(point.y, vpRect.height));
                            
                            // Update visual marker with constrained position
                            if (point.element) {
                                point.element.style.left = `${point.x}px`;
                                point.element.style.top = `${point.y}px`;
                            }
                        }
                        
                        // Reset the dragging index
                        window.draggingPointIndex = -1;
                        selectedPointIndex = -1; // Clear selection
                    }
                });
                
                console.log("Waypoint controls set up - permanently in WAM mode");
            }

            // --- Initial Call --- //
            
            // Create base DOM elements
            initializeRects();
            
            // Set up event handlers and controls (before state restoration)
            setupRotationControls(); // Set up rotation control event handlers
            setupDurationControl(); // Set up duration control
            setupViewportActions(); // Set up viewport action buttons
            setupWaypointControls(); // Set up waypoint controls - will enable permanent WAM
            setupXFormManagement(); // Set up X-Form management UI
            
            // Now restore state (will override initial values with saved ones)
            const isStateRestored = restoreState();
            
            // Apply duration feedback now that values are restored
            if (document.getElementById('durationFeedback')) {
                const value = parseInt(window.durationInput.value, 10);
                if (!isNaN(value)) {
                    const seconds = (value / 1000).toFixed(1);
                    document.getElementById('durationFeedback').textContent = `(${seconds}s)`;
                }
            }
            
            // Only render saved list if the element exists
            if (window.savedListUl) {
                window.renderSavedList();
            } else {
                console.log("Skipping renderSavedList at initialization - element not found");
            }
            
            // Only apply theme from localStorage if we didn't restore it from state
            if (!isStateRestored) {
                applyTheme(savedTheme);
            }
            
            // Start the timer for updating time-based names if using datetime format
            if (namingConventionSelect && namingConventionSelect.value === 'datetime') {
                updateTimeBasedName(); // Update immediately
                window.timeUpdateTimer = setInterval(updateTimeBasedName, 1000);
            }
            
            // Update counters and UI after state is restored
            window.updateWaypointCounter();
            updateRotationButtonsUI(); // Ensure rotation buttons reflect the correct state
            
            // Finally, set up state persistence for future changes
            setupStatePersistence();
            
            // Initialize filename mode (Phase 1 & 2)
            setupFilenameMode();
            
            // Make sure the filename is immediately visible
            initializeFilenameDisplay();
            
            console.log("Application initialized" + (isStateRestored ? " with restored state" : " with default state"));

            // Add this listener if it was accidentally removed
            if (themeToggleButton) {
                themeToggleButton.addEventListener('click', () => {
                    console.log("Theme toggle clicked!"); // Check listener firing
                    const currentTheme = document.documentElement.classList.contains('dark-theme') ? 'dark' : 'light';
                    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                    applyTheme(newTheme);
                });
            }
 
        });

        // Helper to update the rotation button UI based on current rotation settings
        function updateRotationButtonsUI() {
            // Update X rotation button UI
            const xToggle = document.querySelector('.direction-toggle[data-axis="x"]');
            if (xToggle) {
                xToggle.setAttribute('data-direction', window.xRotationDirection);
                const buttons = xToggle.querySelectorAll('.btn-dir');
                buttons.forEach(button => {
                    const value = parseInt(button.getAttribute('data-value'), 10);
                    if (value === window.xRotationDirection) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
            }
            
            // Update Y rotation button UI
            const yToggle = document.querySelector('.direction-toggle[data-axis="y"]');
            if (yToggle) {
                yToggle.setAttribute('data-direction', window.yRotationDirection);
                const buttons = yToggle.querySelectorAll('.btn-dir');
                buttons.forEach(button => {
                    const value = parseInt(button.getAttribute('data-value'), 10);
                    if (value === window.yRotationDirection) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
            }
            
            // Update Z rotation button UI
            const zToggle = document.querySelector('.direction-toggle[data-axis="z"]');
            if (zToggle) {
                zToggle.setAttribute('data-direction', window.zRotationDirection);
                const buttons = zToggle.querySelectorAll('.btn-dir');
                buttons.forEach(button => {
                    const value = parseInt(button.getAttribute('data-value'), 10);
                    if (value === window.zRotationDirection) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
            }
        }
        
        // Register state-saving events
        function setupStatePersistence() {
            // Save on rectangle position changes (drag end) - Now handled directly in the drag function
            
            // Save on waypoint changes
            const saveOnWaypointChange = () => setTimeout(window.saveCurrentState, 50);
            viewport.addEventListener('click', (e) => {
                // Save when a waypoint is added
                if (e.target === viewport) {
                    saveOnWaypointChange();
                }
            });
            
            // Save after waypoint dragging
            document.addEventListener('mouseup', () => {
                if (window.draggingPointIndex >= 0) {
                    saveOnWaypointChange();
                }
            });
            
            // Save on Delete button click
            if (window.deleteLastWaypointButton) {
                window.deleteLastWaypointButton.addEventListener('click', saveOnWaypointChange);
            }
            
            // Save on rotation changes
            document.querySelectorAll('.direction-toggle .btn-dir').forEach(button => {
                button.addEventListener('click', saveOnWaypointChange);
            });
            
            // Save on duration changes
            if (window.durationInput) {
                window.durationInput.addEventListener('change', saveOnWaypointChange);
            }
            
            // Save on rectangle dimension changes
            if (window.widthInput) {
                window.widthInput.addEventListener('change', saveOnWaypointChange);
            }
            if (window.heightInput) {
                window.heightInput.addEventListener('change', saveOnWaypointChange);
            }
            
            // Save on theme changes
            if (window.themeToggleButton) {
                window.themeToggleButton.addEventListener('click', saveOnWaypointChange);
            }
            
            // Save on X-Form rename
            if (window.renameXFormButton) {
                window.renameXFormButton.addEventListener('click', saveOnWaypointChange);
            }
            
            console.log('State persistence set up - changes will be automatically saved');
        }

        // --- Waypoint Counter Update --- //
        function updateWaypointCounter() {
            if (!window.intermediatePoints || !window.waypointCounter || !window.deleteLastWaypointButton || !window.addWaypointButton) {
                console.error("Required global variables not defined for updateWaypointCounter");
                return;
            }
            
            const count = window.intermediatePoints.length;
            window.waypointCounter.textContent = count;
            const isDisabled = count === 0;
            
            // Update the Delete button state
            window.deleteLastWaypointButton.disabled = isDisabled;
            
            // Handle pointer events to prevent any mouse interaction when disabled
            if (isDisabled) {
                window.deleteLastWaypointButton.style.pointerEvents = 'none';
                window.deleteLastWaypointButton.style.opacity = '0.5';
                window.deleteLastWaypointButton.style.cursor = 'not-allowed';
            } else {
                window.deleteLastWaypointButton.style.pointerEvents = 'auto';
                window.deleteLastWaypointButton.style.opacity = '1';
                window.deleteLastWaypointButton.style.cursor = 'pointer';
            }
            
            // Cap the maximum number of waypoints
            window.addWaypointButton.disabled = count >= 99;
            
            console.log(`Waypoint counter updated: ${count} points`);
        }
        
        // Export function to global scope
        window.updateWaypointCounter = updateWaypointCounter;

        // --- Theming --- //
        function applyTheme(theme) {
            const htmlElement = document.documentElement; // Target <html> tag
            if (theme === 'dark') {
                htmlElement.classList.add('dark-theme');
            } else {
                htmlElement.classList.remove('dark-theme');
            }
            localStorage.setItem('xformMakerTheme', theme); // Updated key name
        }

        // --- Render Saved List ---
        function renderSavedList() {
            if (!window.savedListUl) {
                console.log("Skipping render of saved list - savedListUl element not found");
                return;
            }
            
            const xforms = window.getSavedXForms();
            window.savedListUl.innerHTML = ''; // Clear existing list
            window.selectedSavedXFormId = null; // Clear selection
            window.selectedControlsDiv.style.display = 'none'; // Hide controls

            if (xforms.length === 0) {
                window.savedListUl.innerHTML = '<li>No X-Forms saved yet.</li>';
                return;
            }

            // Sort by most recent first
            xforms.sort((a, b) => b.timestamp - a.timestamp);

            xforms.forEach(t => {
                const li = document.createElement('li');
                li.dataset.id = t.id;
                li.className = 'xform-list-item';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'xform-name';
                nameSpan.textContent = t.name || `X-Form ${t.id.substring(0, 6)}`;
                li.appendChild(nameSpan);

                // Simple indication of complexity (optional)
                const detailsSpan = document.createElement('span');
                detailsSpan.className = 'xform-details';
                detailsSpan.textContent = `(${t.waypoints ? t.waypoints.length : 0} pts)`;
                li.appendChild(detailsSpan);
                
                // Quick action buttons
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'xform-actions';
                
                // Load button
                const loadBtn = document.createElement('button');
                loadBtn.className = 'list-icon-btn';
                loadBtn.title = 'Load';
                loadBtn.innerHTML = '<img src="icons/edit-white.png" alt="Load" class="btn-icon-small" data-dark-src="icons/edit-black.png">';
                loadBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Don't trigger the li click
                    window.selectedSavedXFormId = t.id;
                    const xforms = window.getSavedXForms();
                    const selected = xforms.find(x => x.id === t.id);
                    if (selected) {
                        applyXFormData(selected);
                        console.log(`Quick-loaded X-Form: ${selected.name}`);
                        // Highlight the selected item
                        Array.from(window.savedListUl.querySelectorAll('li')).forEach(el => el.classList.remove('selected'));
                        li.classList.add('selected');
                    }
                });
                actionsDiv.appendChild(loadBtn);
                
                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'list-icon-btn';
                deleteBtn.title = 'Delete';
                deleteBtn.innerHTML = '<img src="icons/trash-white.png" alt="Delete" class="btn-icon-small" data-dark-src="icons/trash-black.png">';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Don't trigger the li click
                    if (confirm(`Are you sure you want to delete "${t.name}"?`)) {
                        const xforms = window.getSavedXForms();
                        const filtered = xforms.filter(x => x.id !== t.id);
                        window.saveXForms(filtered);
                        window.renderSavedList();
                    }
                });
                actionsDiv.appendChild(deleteBtn);
                
                li.appendChild(actionsDiv);

                li.addEventListener('click', () => {
                    // Toggle selection
                    Array.from(window.savedListUl.querySelectorAll('li')).forEach(el => el.classList.remove('selected'));
                    
                    if (window.selectedSavedXFormId === t.id) {
                        window.selectedSavedXFormId = null;
                        window.selectedControlsDiv.style.display = 'none';
                    } else {
                        window.selectedSavedXFormId = t.id;
                        li.classList.add('selected');
                        window.renameInput.value = t.name; // Pre-fill rename input
                        window.selectedControlsDiv.style.display = 'block';
                        console.log('Selected saved X-Form:', t.id);
                    }
                });
                window.savedListUl.appendChild(li);
            });
            
            // Update icons for theme
            if (typeof updateIconsForTheme === 'function') {
                setTimeout(updateIconsForTheme, 50);
            }
        }
        
        // Export function to global scope
        window.renderSavedList = renderSavedList;
        
        // --- Bezier/Spline Calculation Helpers ---

        // Initialize the filename mode and start updates
        function initializeFilenameDisplay() {
            // Get the current filename input
            const filenameInput = document.getElementById('filenameInput');
            if (!filenameInput) {
                console.error("Cannot initialize filename display - element not found");
                return;
            }
            
            console.log("Initializing filename display");
            
            // Force an immediate update regardless of mode
            const now = new Date();
            const formattedDate = now.toISOString().slice(0, 10).replace(/-/g, '-');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const timeStr = `${hours}:${minutes}:${seconds}`;
            
            // Create the new filename
            const newFilename = `${formattedDate} ${timeStr}`;
            
            // Update input field
            filenameInput.value = newFilename;
            console.log("Initial filename set:", newFilename);
            
            // If in ATM mode, start updates
            if (window.isFilenameModeATM) {
                startFilenameTimeUpdates();
            }
        }

        // Helper function to save the current X-Form to storage
        function saveCurrentXFormToStorage() {
            // Ensure we have a valid name and ID
            if (!currentXFormId) {
                currentXFormId = Date.now();
            }
            
            // Use the current filename from the input if available
            const filenameInput = document.getElementById('filenameInput');
            if (filenameInput && filenameInput.value) {
                currentXFormName = filenameInput.value;
            }
            
            // Create X-Form data object
            const xformData = createXFormDataObject();
            
            // Check if we're updating an existing X-Form
            const xforms = window.getSavedXForms();
            const existingIndex = xforms.findIndex(t => t.id === currentXFormId);
            
            if (existingIndex >= 0) {
                // Update existing
                xforms[existingIndex] = xformData;
            } else {
                // Add new
                xforms.push(xformData);
            }
            
            // Save to localStorage
            window.saveXForms(xforms);
            
            // Update the UI if the function exists
            if (window.renderSavedList) {
                window.renderSavedList();
            }
            
            return xformData;
        }
    </script>

</body></html>